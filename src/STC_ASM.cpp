//----------------------------------------------------------------------------------------------------------------
//// FILENAME			: PLC_STCASM.cpp
// ORIGIN AUTHOR		: Hsien	,	2012.04.23
// EDITOR				: Hsien
// NOTE					: 
//						the ST compiler assembly , including :
//				1. DQI , Database Query Interface
//				2. VAR2IRC , conversion and verification function for variable representation in ST 
//				3. IRC , Intermeidate Representation Codes , the definition of target code of ST compiler
//				4. lex and yacc parser , engine of this compiler ,generated from specification file st.l  , st.y
//				*5.PCDPM , parent-child data propagation mechanism , used to control output file stream , in order to output program-branch.
//-----------------------------------------------------------------------------------------------------------------
#include<STC_ASM.h>
/*static*/ //queue<IRC_UNIT>	trunk;			// global 'queue' would provoke assertion error in CLR memory model , Hsien , 2012.06.07
												// alternative way : cancel this global variable , 
												// after parser finishing , doing value-copying from inside of parser to external queue.
#define _CRTDBG_MAP_ALLOC
#include <stdlib.h>
#include <crtdbg.h>

//---------------------------
//	Global Data Pool
//---------------------------
extern FILE*		stin			;			//	point to input source
extern int			stparse()		;			//	generated by lex&yacc
extern void			stparseClose()	;		
extern void			strestart( FILE *);


//-------------------
//	Instance Datas
//-------------------
IRC_UNIT			outputElement	;			// global buffer for all code-generating process
int					generation	= CHILD	;		// used to control which branch to output
PCDPM_FAMILY		outputQueue		;			// for standard output(IRC code instructions) of STC
/*PCDPM_FAMILY		errorQueue		;*/			// for standard error output of STC , it was a stack acutually , Hsien , 2012.10.11
/*FILE*				errorTrunk		;
size_t*				errorCount		;*/			// link to errorQueue's write count , when initializing

//extern	size_t*		errorCount;
//---------------
//	References
//---------------
sqlite3				*refDb			=	NULL;		// reference from external
STC_ERRHDL			*refErrorHdl	=	NULL;		// reference from external	

int stcInit(/*const char* dbPath*/sqlite3*	_db,STC_ERRHDL*	_errorHdl)
{
	//-----------------------------------
	//	initializing : open data base
	//-----------------------------------
	refErrorHdl = _errorHdl	;
	refDb		= _db		;

	//if(stcErrorHandler(errorHdl,MOD_DQI,dqiInit(&db,dbPath),"",0) == STC_FATAL)
	//	return STC_FATAL;


	//_CrtDumpMemoryLeaks();

	//--------------------------
	//	initializing error queue
	//		CALCELED : error handler should be initialized individualy
	//--------------------------
	//errorTrunk = tmpfile();
	//if(stcErrorHandler(MOD_PCDPM,pcdpmInit(&errorQueue,errorTrunk,sizeof(STC_ERRBLK)),"",0) == STC_FATAL)
	//	return STC_FATAL;

	//errorCount = &(errorQueue.youngest->counts);

	strset(textBuffer,0);
	strset(outBuffer,0);

	return STC_SUCCESS;
}

void stcClose()
{
//	dqiClose(db);
	stparseClose();
//	pcdpmClose(&errorQueue);
//	fclose(errorTrunk);
}
//int stcReadError(STC_ERRBLK	*outBlk)
//{
//	//------------------------------------
//	//	public interface for reading error
//	//------------------------------------
//	if(*errorCount == 0)
//		return STC_NO_MORE_ERROR;				// no more error
//	
//	pcdpmReadData(&errorQueue,outBlk,0);		// read out blk
//
//	return STC_SUCCESS;
//}

int stcCompile(FILE*	inputFp,FILE* outputFp,int mode)
{
	FILE*	tmpOutputFp = tmpfile();
	char	copyBuf;					// buffer for file-copy

	/*if(stcErrorHandler(MOD_PCDPM
		,*/pcdpmInit(&outputQueue,tmpOutputFp/*outputFp*/,sizeof(IRC_UNIT));/*)
		,""
		,0) == STC_FATAL)
		return STC_ERROR;	*/				// if outputFp is invalid
//	pcdpmResetData(&errorQueue,0);
	
	stin	= inputFp;						//	change the input source of yyparse()
//	stparseClose();
//	strestart( inputFp);
	stparse();
	/*errCode = *///stparse();				//	return 0 when parsing succesfully
	pcdpmClose(&outputQueue);				//	merge branch to trunk , and close object of outputQueue

	if(/**errorCount*/ stcErrorCount(refErrorHdl)!= 0){		// any error occurs , return immeditatly , wont do output
		fclose(tmpOutputFp);		
		return STC_ERROR;
	}

	//----------------------------------
	//	SUCCESS , do final output : write into output file buffer
	//----------------------------------
///*	if(pcdpmClose(&outputQueue); != PCDPM_SUCCESS)
//			return STC_ERROR;*/			//success

	switch(mode){
		case STC_MODE_NORMAL:	
			//----------------------------
			//	do file-copy upon outputFp
			//----------------------------
			if(outputFp == NULL)
				return STC_ERROR;			// not well-organized yet , Hsien , 2012.10.11
			rewind(tmpOutputFp);
			while(fread(&copyBuf,sizeof(char),1,tmpOutputFp) == 1)
				fwrite(&copyBuf,sizeof(char),1,outputFp);
			break;
		case STC_MODE_CHECK:		
		default:
			//----------------------------
			//	wont do output
			//----------------------------
			break;
	}


	fclose(tmpOutputFp);
	return STC_SUCCESS;
}

